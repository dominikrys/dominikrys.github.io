<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>Executing Stream Cipher Attacks on IP Packets | Dominik Rys</title>
<meta name=keywords content="C++,Security,Networking"><meta name=description content="For part of my bachelor&rsquo;s dissertation, I implemented and executed a bit-flipping attack on encrypted IP packets in LTE networks. The attack was first documented by David Rupprecht et al. in their academic paper &ldquo;Breaking LTE on Layer Two&rdquo;.
The attack is possible due to a specification flaw in LTE standards, where IP packets are not integrity protected. Therefore, a man-in-the-middle (MITM) attacker can modify the packets and the receiver will decrypt them successfully since it can&rsquo;t verify the authenticity of the data. This kind of attack is not specific to LTE networks, however, and can be executed in different environments."><meta name=author content><link rel=canonical href=https://dominikrys.com/posts/stream-cipher-attacks-on-ip/><link crossorigin=anonymous href=/assets/css/stylesheet.f49d66caae9ea0fd43f21f29e71a8d3e284517ed770f2aa86fa012953ad3c9ef.css integrity="sha256-9J1myq6eoP1D8h8p5xqNPihFF+13Dyqob6ASlTrTye8=" rel="preload stylesheet" as=style><link rel=icon href=https://dominikrys.com/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://dominikrys.com/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://dominikrys.com/favicon-32x32.png><link rel=apple-touch-icon href=https://dominikrys.com/apple-touch-icon.png><link rel=mask-icon href=https://dominikrys.com/safari-pinned-tab.svg><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate hreflang=en href=https://dominikrys.com/posts/stream-cipher-attacks-on-ip/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--code-block-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><script async src="https://www.googletagmanager.com/gtag/js?id=G-FZL8HVTHR8"></script><script>var dnt,doNotTrack=!1;if(!1&&(dnt=navigator.doNotTrack||window.doNotTrack||navigator.msDoNotTrack,doNotTrack=dnt=="1"||dnt=="yes"),!doNotTrack){window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag("js",new Date),gtag("config","G-FZL8HVTHR8")}</script><meta property="og:url" content="https://dominikrys.com/posts/stream-cipher-attacks-on-ip/"><meta property="og:site_name" content="Dominik Rys"><meta property="og:title" content="Executing Stream Cipher Attacks on IP Packets"><meta property="og:description" content="For part of my bachelor‚Äôs dissertation, I implemented and executed a bit-flipping attack on encrypted IP packets in LTE networks. The attack was first documented by David Rupprecht et al. in their academic paper ‚ÄúBreaking LTE on Layer Two‚Äù.
The attack is possible due to a specification flaw in LTE standards, where IP packets are not integrity protected. Therefore, a man-in-the-middle (MITM) attacker can modify the packets and the receiver will decrypt them successfully since it can‚Äôt verify the authenticity of the data. This kind of attack is not specific to LTE networks, however, and can be executed in different environments."><meta property="og:locale" content="en"><meta property="og:type" content="article"><meta property="article:section" content="posts"><meta property="article:published_time" content="2021-07-09T15:36:55+01:00"><meta property="article:modified_time" content="2021-07-09T15:36:55+01:00"><meta property="article:tag" content="C++"><meta property="article:tag" content="Security"><meta property="article:tag" content="Networking"><meta property="og:image" content="https://dominikrys.com/img/cover.jpg"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="https://dominikrys.com/img/cover.jpg"><meta name=twitter:title content="Executing Stream Cipher Attacks on IP Packets"><meta name=twitter:description content="For part of my bachelor&rsquo;s dissertation, I implemented and executed a bit-flipping attack on encrypted IP packets in LTE networks. The attack was first documented by David Rupprecht et al. in their academic paper &ldquo;Breaking LTE on Layer Two&rdquo;.
The attack is possible due to a specification flaw in LTE standards, where IP packets are not integrity protected. Therefore, a man-in-the-middle (MITM) attacker can modify the packets and the receiver will decrypt them successfully since it can&rsquo;t verify the authenticity of the data. This kind of attack is not specific to LTE networks, however, and can be executed in different environments."><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Posts","item":"https://dominikrys.com/posts/"},{"@type":"ListItem","position":2,"name":"Executing Stream Cipher Attacks on IP Packets","item":"https://dominikrys.com/posts/stream-cipher-attacks-on-ip/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"Executing Stream Cipher Attacks on IP Packets","name":"Executing Stream Cipher Attacks on IP Packets","description":"For part of my bachelor\u0026rsquo;s dissertation, I implemented and executed a bit-flipping attack on encrypted IP packets in LTE networks. The attack was first documented by David Rupprecht et al. in their academic paper \u0026ldquo;Breaking LTE on Layer Two\u0026rdquo;.\nThe attack is possible due to a specification flaw in LTE standards, where IP packets are not integrity protected. Therefore, a man-in-the-middle (MITM) attacker can modify the packets and the receiver will decrypt them successfully since it can\u0026rsquo;t verify the authenticity of the data. This kind of attack is not specific to LTE networks, however, and can be executed in different environments.\n","keywords":["C++","Security","Networking"],"articleBody":"For part of my bachelor‚Äôs dissertation, I implemented and executed a bit-flipping attack on encrypted IP packets in LTE networks. The attack was first documented by David Rupprecht et al. in their academic paper ‚ÄúBreaking LTE on Layer Two‚Äù.\nThe attack is possible due to a specification flaw in LTE standards, where IP packets are not integrity protected. Therefore, a man-in-the-middle (MITM) attacker can modify the packets and the receiver will decrypt them successfully since it can‚Äôt verify the authenticity of the data. This kind of attack is not specific to LTE networks, however, and can be executed in different environments.\nI learned a lot while implementing this attack, which I thought would be worth documenting and sharing through this post. Some of this post will refer to LTE networks specifically, but I will try to keep much of it general. This post includes how to do bitmasking comfortably in C++, how to find packet offsets using appropriate tools, and how to compensate for any checksum errors in IP packets.\nStream Cipher Attack Explanation In most LTE networks, IP packets are encrypted with a stream cipher (AES-CTR), where the encryption algorithm generates streams of bytes called keystreams. To encrypt data, the sender XORs the unencrypted message (the plaintext) with the keystream to obtain an encrypted message (the ciphertext). The ciphertext is then sent to the receiver. The receiver generates the same keystream and can XOR it with the received ciphertext to retrieve the plaintext.\nAs explained previously, a MITM attacker can successfully modify the ciphertext of internet packets in LTE networks such that they decrypt to a related plaintext. This is possible because the encryption algorithm used is a malleable cipher. If the attacker knows part of the plaintext of the encrypted data, they can apply a calculated manipulation mask (also referred to as a bitmask) to the ciphertext such that it decrypts into any chosen plaintext. The mask is calculated by XORing the plaintext with the message that the attacker wants to modify the plaintext to. The mask is then applied by XORing it with the ciphertext.\nThe attack works because data XORed with itself results in all zeroes, and all zeros XORed with any data keeps the data intact. For more detail, I highly recommend reading a short description of how the attack works on Wikipedia.\nAn attacker can apply the mask to only a part of the ciphertext, allowing for the attack if the entire plaintext is not known.\nAs an example, in the context of LTE networks, the network provides the IP of the DNS server that connected devices should use for DNS resolution. Therefore, the plaintext of the destination IP of DNS requests is known. A MITM attacker can use this to change the destination IP to an arbitrary address, hijacking the request.\nImplementing the Bit-Flipping Stream Cipher Attack in C++ With the basics out of the way, I will explain how to implement a bit-flipping stream cipher attack where the plaintext is known in C++.\nObtaining Field Offsets The encrypted packets can be encapsulated in various protocols, so the offset at which to apply the bitmask will differ depending on the context. With more common protocols, you can easily find this information on the internet. In other cases, Wireshark and some testing may be needed.\nIn my case of LTE networks and using the C++ srsLTE software suite, I was working with IPv4 packets encapsulated in the LTE PDCP protocol. Obtaining the offset of the destination IP in the IPv4 packet was trivial, but I found Salim Gasmi‚Äôs Hex Packet Decoder to be an excellent tool to help with this. The PDCP protocol only adds a 2-byte header to the front of IP packets, so I needed to add 2 to the IP packet offset for it to work in the context of PDCP packets.\nTo additionally verify if my assumptions were correct, I checked example packets in Wireshark. This would also likely need to be done when finding the offsets of more exotic, less well-documented protocols. To obtain the example packets, I captured packets in a test setup with known keys such that the packets could be decrypted. Since we‚Äôre working with a stream cipher, the offsets will be the same whether encryption is enabled or not. In the Wireshark capture, I was able to confirm that adding 2 to the IP packet offset was correct. This is shown below with the 2-byte PDP header but can also be verified by checking individual bytes.\nApplying Bitmasks to Parts of Payload in C++ We now have the required offsets at which to mask parts of our packets. The next step is to apply the bitmask by XORing it with the encrypted payload. In my case of using srsLTE and LTE networks, the payload was represented by a uint8_t array.\nTo comfortably tweak my implementation and test it without having to set up an entire LTE network, I made myself a test script. To work with real data in the test script, I grabbed some example payloads (encrypted and unencrypted) from a test run and serialised them into a hex string. Then, my test script serialised it back into raw bytes when run. The code I personally used is by Robbie Rosati on Stack Overflow.\nTo calculate the bitmask, the known plaintext of the ciphertext is XORed with the plaintext that you would like the ciphertext to decrypt to. In C++ this is greatly eased by using a std::valarray as it‚Äôs compatible with regular bitwise operations. Then, the mask is XORed with the payload at the appropriate offset. Overall, the entire implementation looks as follows:\nvoid apply_mask(uint8_t* buf, std::valarray\u003cint\u003e mask, int offset) { for (size_t i = offset; i \u003c offset + mask.size(); i++) { buf[i] ^= mask[i - offset]; } } int main() { // De-serialise example payload (for testing only) std::string buf_str = \"80004500004ce33d00007811\"; uint8_t buf[buf_str.length() / 2]; object_from_hex(buf_str, \u0026buf); // Store plaintext and the modified plaintext as std::valarray std::valarray\u003cint\u003e dest_ip_modified{178, 62, 108, 207}; std::valarray\u003cint\u003e dest_ip_plaintext{103, 123, 226, 10}; // Calculate the bitmask auto ip_mask = dest_ip_plaintext ^ dest_ip_modified; // Store the previously found offset of our known plaintext int pdu_dst_ip_byte_offset = 18; // Apply the bitmask to the payload apply_mask(buf, ip_mask, pdu_dst_ip_byte_offset); } Compensating for the IPv4 Checksum In the example above, the destination IP of IPv4 packets is modified. The checksum is left intact, which will most likely be invalid with the new IP address. In effect, these packets will be correctly encrypted, but the network stack at the receiver is likely to discard them.\nFor the receiver to not discard the packets, the checksum will need to be preserved. This can be done by modifying other fields in the packets, whose fields we can reliably predict. To do this, we first need to understand hot IPv4 checksums are calculated. As stated in the Internet Protocol RFC 791:\n‚ÄúThe checksum field is the 16-bit ones‚Äô complement of the ones‚Äô complement sum of all 16-bit words in the header. For purposes of computing the checksum, the value of the checksum field is zero.‚Äù\nThis is quite a mouthful and personally, I found it difficult to grasp without seeing an example. For a great one, I recommend checking the IPv4 header checksum Wikipedia page.\nIn the case of compensating for changes in the destination IP address, this entails calculating the difference between the 16-bit sums of the original and the modified IP addresses and tweaking other fields appropriately. Note that the 16-bit sum will mean that the first and the third octets of each IP address in the sum are shifted left 8 bits in the checksum calculation.\nIn LTE networks, we can reliably predict the TTL of packets sent from some devices to the first mast, as it won‚Äôt yet be decremented. This gives us the ability to compensate for changes in the first and third octets of the IP. To compensate for changes in the second and fourth octets, I performed an investigation by sending hand-crafted DNS packets with broken fields to a remotely hosted VM and checking if they‚Äôre received and processed correctly. The aim was to establish which fields are not necessary for routing and could be modified. This was easily done using Scapy. Eventually, I found that the DSCP and ECN fields could be predicted and didn‚Äôt impact routing, so these gave enough room for me to be able to compensate for changes in the second and fourth octets of the IP.\nIP Checksum Compensation Code Example To verify if my IP checksum compensation code worked, I added an implementation of it to my test script from before.\nTo compensate for changes in the first and third IP octet using the TTL field:\n/* Mask TTL */ // Store the TTL field plaintext int ttl_plaintext = 64; // Calculate the difference in the 16-bit totals of the original and modified destination IPs int dest_ip_plaintext_total = (dest_ip_plaintext[0] \u003c\u003c 8) + dest_ip_plaintext[1] + (dest_ip_plaintext[2] \u003c\u003c 8) + dest_ip_plaintext[3]; int dest_ip_modified_total = (dest_ip_modified[0] \u003c\u003c 8) + dest_ip_modified[1] + (dest_ip_modified[2] \u003c\u003c 8) + dest_ip_modified[3]; int chksm_difference = dest_ip_plaintext_total + (ttl_plaintext \u003c\u003c 8) - dest_ip_modified_total; // Extract only the higher byte from the difference that the TTL field can compensate for int ttl_modified = chksm_difference \u003e\u003e 8; // Assert that the modified TTL field is valid assert(ttl_modified \u003e= 20 \u0026\u0026 \"TTL under 20: may not reach the destination\"); assert(ttl_modified \u003c= 255 \u0026\u0026 \"TTL over 255: too large\"); // Calculate the bitmask int ttl_mask_val = ttl_plaintext ^ttl_modified; std::valarray\u003cint\u003e ttl_mask = {ttl_mask_val}; // Apply the bitmask to the ciphertext int ttl_byte_offset = 10; apply_mask(buf, ttl_mask, ttl_byte_offset); To compensate for changes in the second and fourth IP octet using the DSCP and ECN fields:\n/* Mask DSCP/ECN */ // Store the DSCP/ECN field plaintext int dscp_ecn_plaintext = 0; // Extract only the lower byte from the difference that the DSCP/ECN field can compensate for int dscp_ecn_modified = chksm_difference \u0026 0xFF; // Assert that the modified DSCP/ECN value is valid assert(dscp_ecn_mod \u003e= 0 \u0026\u0026 \"DSPCP/ECN under 1: invalid\"); assert(dscp_ecn_mod \u003c= 255 \u0026\u0026 \"DSPCP/ECN above 255: invalid\"); // Calculate the bitmask int dscp_ecn_mask_val = dscp_ecn_plain ^dscp_ecn_mod; std::valarray\u003cint\u003e dscp_ecn_mask = {dscp_ecn_mask_val}; // Apply the bitmask to the ciphertext int pdu_dscp_ecn_byte_offset = 3; apply_mask(buf, dscp_ecn_mask, pdu_dscp_ecn_byte_offset); Caveats of Stream Cipher Attacks on IP Packets Impossible to Compensate for Changes You may that it won‚Äôt be possible to compensate for some changes in the fields, especially to the higher byte of the 16-bit sum. The lower byte can always carry into the higher byte, but the higher byte doesn‚Äôt have this luxury. If it‚Äôs not possible to find enough fields whose plaintext can be predicted, it may not be possible to compensate for any changes unless some external changes are made.\nThis is an issue that I have encountered, where the destination IP couldn‚Äôt be compensated for. In my case, I was redirecting DNS packets to a remote VM that I controlled, so I had control over the modified destination IP. I fixed this issue by deploying a VM hosted by another provider or in another region, such that the IP would differ adequately.\nIncorrect UDP/TCP Checksums Another issue that could occur is that the UDP checksum will be incorrect, causing the receiver to discard the packet. This occurs because the UDP checksum is calculated separately from the IP checksum. If you control the receiver, this issue could be alleviated by ignoring UDP checksums. There is conflicting advice on how to do this online, so I wrote a short guide to disabling UDP checksum validation in Linux which you can find here.\nI‚Äôve attempted to correct the UDP checksum by masking other fields in the packet as well. Below is a diagram of all the fields that are used to calculate the UDP checksum, where the red fields are from the IPv4 packet:\nAfter modifying every non-payload field to see if the packets will be received, I found that Linux rejected them at the kernel level. The only promising change that worked was when part of the payload could be predicted and modified. Otherwise, pervasive changes would need to be made to the IP stack such that any incorrect fields are ignored and corrected.\n","wordCount":"2033","inLanguage":"en","image":"https://dominikrys.com/img/cover.jpg","datePublished":"2021-07-09T15:36:55+01:00","dateModified":"2021-07-09T15:36:55+01:00","mainEntityOfPage":{"@type":"WebPage","@id":"https://dominikrys.com/posts/stream-cipher-attacks-on-ip/"},"publisher":{"@type":"Organization","name":"Dominik Rys","logo":{"@type":"ImageObject","url":"https://dominikrys.com/favicon.ico"}}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://dominikrys.com/ accesskey=h title="Dominik Rys (Alt + H)">Dominik Rys</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)" aria-label="Toggle theme"><svg id="moon" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://dominikrys.com/tags title=üîñ‚ÄáTags><span>üîñ‚ÄáTags</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><h1 class="post-title entry-hint-parent">Executing Stream Cipher Attacks on IP Packets</h1><div class=post-meta><span title='2021-07-09 15:36:55 +0100 +0100'>July 9, 2021</span>&nbsp;¬∑&nbsp;10 min</div></header><figure class=entry-cover><img loading=eager srcset='https://dominikrys.com/posts/stream-cipher-attacks-on-ip/img/cover_hu_aea3b86fbd6a365b.jpg 360w,https://dominikrys.com/posts/stream-cipher-attacks-on-ip/img/cover_hu_6ea6aee99cac0f1c.jpg 480w,https://dominikrys.com/posts/stream-cipher-attacks-on-ip/img/cover_hu_b22f568e4e2a9c09.jpg 720w,https://dominikrys.com/posts/stream-cipher-attacks-on-ip/img/cover_hu_654b0293068916f8.jpg 1080w,https://dominikrys.com/posts/stream-cipher-attacks-on-ip/img/cover_hu_60ce084798243e93.jpg 1500w,https://dominikrys.com/posts/stream-cipher-attacks-on-ip/img/cover.jpg 2219w' src=https://dominikrys.com/posts/stream-cipher-attacks-on-ip/img/cover.jpg sizes="(min-width: 768px) 720px, 100vw" width=2219 height=982 alt></figure><div class=toc><details open><summary accesskey=c title="(Alt + C)"><span class=details>Table of Contents</span></summary><div class=inner><ul><li><a href=#stream-cipher-attack-explanation aria-label="Stream Cipher Attack Explanation">Stream Cipher Attack Explanation</a></li><li><a href=#implementing-the-bit-flipping-stream-cipher-attack-in-c aria-label="Implementing the Bit-Flipping Stream Cipher Attack in C++">Implementing the Bit-Flipping Stream Cipher Attack in C++</a><ul><li><a href=#obtaining-field-offsets aria-label="Obtaining Field Offsets">Obtaining Field Offsets</a></li><li><a href=#applying-bitmasks-to-parts-of-payload-in-c aria-label="Applying Bitmasks to Parts of Payload in C++">Applying Bitmasks to Parts of Payload in C++</a></li><li><a href=#compensating-for-the-ipv4-checksum aria-label="Compensating for the IPv4 Checksum">Compensating for the IPv4 Checksum</a><ul><li><a href=#ip-checksum-compensation-code-example aria-label="IP Checksum Compensation Code Example">IP Checksum Compensation Code Example</a></li></ul></li></ul></li><li><a href=#caveats-of-stream-cipher-attacks-on-ip-packets aria-label="Caveats of Stream Cipher Attacks on IP Packets">Caveats of Stream Cipher Attacks on IP Packets</a><ul><li><a href=#impossible-to-compensate-for-changes aria-label="Impossible to Compensate for Changes">Impossible to Compensate for Changes</a></li><li><a href=#incorrect-udptcp-checksums aria-label="Incorrect UDP/TCP Checksums">Incorrect UDP/TCP Checksums</a></li></ul></li></ul></div></details></div><div class=post-content><p>For part of my bachelor&rsquo;s dissertation, I implemented and executed a bit-flipping attack on encrypted IP packets in LTE networks. The attack was first documented by David Rupprecht et al. in their academic paper <a href=https://alter-attack.net/>&ldquo;Breaking LTE on Layer Two&rdquo;</a>.</p><p>The attack is possible due to a specification flaw in LTE standards, where IP packets are <strong>not integrity protected</strong>. Therefore, a man-in-the-middle (MITM) attacker can modify the packets and the receiver will decrypt them successfully since it can&rsquo;t verify the authenticity of the data. This kind of attack is not specific to LTE networks, however, and can be executed in different environments.</p><p>I learned a lot while implementing this attack, which I thought would be worth documenting and sharing through this post. Some of this post will refer to LTE networks specifically, but I will try to keep much of it general. This post includes how to do bitmasking comfortably in C++, how to find packet offsets using appropriate tools, and how to compensate for any checksum errors in IP packets.</p><h2 id=stream-cipher-attack-explanation>Stream Cipher Attack Explanation<a hidden class=anchor aria-hidden=true href=#stream-cipher-attack-explanation>#</a></h2><p>In most LTE networks, IP packets are encrypted with a <strong>stream cipher</strong> (AES-CTR), where the encryption algorithm generates streams of bytes called <strong>keystreams</strong>. To encrypt data, the sender XORs the unencrypted message (the <strong>plaintext</strong>) with the keystream to obtain an encrypted message (the <strong>ciphertext</strong>). The ciphertext is then sent to the receiver. The receiver generates the same keystream and can XOR it with the received ciphertext to retrieve the plaintext.</p><figure><img loading=lazy src=img/stream-cipher-diagram.png alt="Stream Cipher Diagram"></figure><p>As explained previously, a MITM attacker can successfully modify the ciphertext of internet packets in LTE networks such that they decrypt to a related plaintext. This is possible because the encryption algorithm used is a <a href=https://en.wikipedia.org/wiki/Malleability_%28cryptography%29><strong>malleable cipher</strong></a>. If the attacker knows part of the plaintext of the encrypted data, they can apply a calculated <strong>manipulation mask</strong> (also referred to as a <strong>bitmask</strong>) to the ciphertext such that it decrypts into <em>any</em> chosen plaintext. The mask is calculated by XORing the plaintext with the message that the attacker wants to modify the plaintext to. The mask is then applied by XORing it with the ciphertext.</p><p>The attack works because data XORed with itself results in all zeroes, and all zeros XORed with any data keeps the data intact. For more detail, I highly recommend reading a short description of how the attack works on <a href=https://en.wikipedia.org/wiki/Stream_cipher_attacks#Bit-flipping_attack>Wikipedia</a>.</p><figure class=align-center><img loading=lazy src=img/attack-diagram.png#center alt="Attack Diagram"></figure><p>An attacker can apply the mask to only a part of the ciphertext, allowing for the attack if the entire plaintext is not known.</p><p>As an example, in the context of LTE networks, the network provides the IP of the DNS server that connected devices should use for DNS resolution. Therefore, the plaintext of the destination IP of DNS requests is known. A MITM attacker can use this to change the destination IP to an arbitrary address, hijacking the request.</p><h2 id=implementing-the-bit-flipping-stream-cipher-attack-in-c>Implementing the Bit-Flipping Stream Cipher Attack in C++<a hidden class=anchor aria-hidden=true href=#implementing-the-bit-flipping-stream-cipher-attack-in-c>#</a></h2><p>With the basics out of the way, I will explain how to implement a bit-flipping stream cipher attack where the plaintext is known in C++.</p><h3 id=obtaining-field-offsets>Obtaining Field Offsets<a hidden class=anchor aria-hidden=true href=#obtaining-field-offsets>#</a></h3><p>The encrypted packets can be encapsulated in various protocols, so the offset at which to apply the bitmask will differ depending on the context. With more common protocols, you can easily find this information on the internet. In other cases, Wireshark and some testing may be needed.</p><p>In my case of LTE networks and using the C++ <a href=https://www.srslte.com/>srsLTE</a> software suite, I was working with IPv4 packets encapsulated in the LTE PDCP protocol. Obtaining the offset of the destination IP in the IPv4 packet was trivial, but I found <a href=https://hpd.gasmi.net/>Salim Gasmi&rsquo;s Hex Packet Decoder</a> to be an excellent tool to help with this. The PDCP protocol only adds a 2-byte header to the front of IP packets, so I needed to add 2 to the IP packet offset for it to work in the context of PDCP packets.</p><p>To additionally verify if my assumptions were correct, I checked example packets in Wireshark. This would also likely need to be done when finding the offsets of more exotic, less well-documented protocols. To obtain the example packets, I captured packets in a test setup with known keys such that the packets could be decrypted. Since we&rsquo;re working with a stream cipher, the offsets will be the same whether encryption is enabled or not. In the Wireshark capture, I was able to confirm that adding 2 to the IP packet offset was correct. This is shown below with the 2-byte PDP header but can also be verified by checking individual bytes.</p><figure class=align-center><img loading=lazy src=img/pdcp-trace.png#center alt="Wireshark PDCP Trace"></figure><h3 id=applying-bitmasks-to-parts-of-payload-in-c>Applying Bitmasks to Parts of Payload in C++<a hidden class=anchor aria-hidden=true href=#applying-bitmasks-to-parts-of-payload-in-c>#</a></h3><p>We now have the required offsets at which to mask parts of our packets. The next step is to apply the bitmask by XORing it with the encrypted payload. In my case of using <a href=https://www.srslte.com/>srsLTE</a> and LTE networks, the payload was represented by a <code>uint8_t</code> array.</p><p>To comfortably tweak my implementation and test it without having to set up an entire LTE network, I made myself a test script. To work with real data in the test script, I grabbed some example payloads (encrypted and unencrypted) from a test run and serialised them into a hex string. Then, my test script serialised it back into raw bytes when run. The code I personally used is by <a href=https://stackoverflow.com/questions/17452689/read-write-binary-object-as-hex/17452690#17452690>Robbie Rosati on Stack Overflow</a>.</p><p>To calculate the bitmask, the known plaintext of the ciphertext is XORed with the plaintext that you would like the ciphertext to decrypt to. In C++ this is greatly eased by using a <code>std::valarray</code> as it&rsquo;s compatible with regular bitwise operations. Then, the mask is XORed with the payload at the appropriate offset. Overall, the entire implementation looks as follows:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span><span style=color:#66d9ef>void</span> <span style=color:#a6e22e>apply_mask</span>(<span style=color:#66d9ef>uint8_t</span><span style=color:#f92672>*</span> buf, std<span style=color:#f92672>::</span>valarray<span style=color:#f92672>&lt;</span><span style=color:#66d9ef>int</span><span style=color:#f92672>&gt;</span> mask, <span style=color:#66d9ef>int</span> offset)
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>for</span> (size_t i <span style=color:#f92672>=</span> offset; i <span style=color:#f92672>&lt;</span> offset <span style=color:#f92672>+</span> mask.size(); i<span style=color:#f92672>++</span>) {
</span></span><span style=display:flex><span>    buf[i] <span style=color:#f92672>^=</span> mask[i <span style=color:#f92672>-</span> offset];
</span></span><span style=display:flex><span>  }
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>int</span> <span style=color:#a6e22e>main</span>() {
</span></span><span style=display:flex><span>  <span style=color:#75715e>// De-serialise example payload (for testing only)
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>  std<span style=color:#f92672>::</span>string buf_str <span style=color:#f92672>=</span> <span style=color:#e6db74>&#34;80004500004ce33d00007811&#34;</span>;
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>uint8_t</span> buf[buf_str.length() <span style=color:#f92672>/</span> <span style=color:#ae81ff>2</span>];
</span></span><span style=display:flex><span>  object_from_hex(buf_str, <span style=color:#f92672>&amp;</span>buf);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  <span style=color:#75715e>// Store plaintext and the modified plaintext as std::valarray
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>  std<span style=color:#f92672>::</span>valarray<span style=color:#f92672>&lt;</span><span style=color:#66d9ef>int</span><span style=color:#f92672>&gt;</span> dest_ip_modified{<span style=color:#ae81ff>178</span>, <span style=color:#ae81ff>62</span>, <span style=color:#ae81ff>108</span>, <span style=color:#ae81ff>207</span>};
</span></span><span style=display:flex><span>  std<span style=color:#f92672>::</span>valarray<span style=color:#f92672>&lt;</span><span style=color:#66d9ef>int</span><span style=color:#f92672>&gt;</span> dest_ip_plaintext{<span style=color:#ae81ff>103</span>, <span style=color:#ae81ff>123</span>, <span style=color:#ae81ff>226</span>, <span style=color:#ae81ff>10</span>};
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  <span style=color:#75715e>// Calculate the bitmask
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>  <span style=color:#66d9ef>auto</span> ip_mask <span style=color:#f92672>=</span> dest_ip_plaintext <span style=color:#f92672>^</span> dest_ip_modified;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  <span style=color:#75715e>// Store the previously found offset of our known plaintext
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>  <span style=color:#66d9ef>int</span> pdu_dst_ip_byte_offset <span style=color:#f92672>=</span> <span style=color:#ae81ff>18</span>;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  <span style=color:#75715e>// Apply the bitmask to the payload
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>  apply_mask(buf, ip_mask, pdu_dst_ip_byte_offset);
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><h3 id=compensating-for-the-ipv4-checksum>Compensating for the IPv4 Checksum<a hidden class=anchor aria-hidden=true href=#compensating-for-the-ipv4-checksum>#</a></h3><p>In the example above, the destination IP of IPv4 packets is modified. The checksum is left intact, which will most likely be invalid with the new IP address. In effect, these packets will be correctly encrypted, but the network stack at the receiver is likely to discard them.</p><p>For the receiver to not discard the packets, the checksum will need to be preserved. This can be done by modifying other fields in the packets, whose fields we can reliably predict. To do this, we first need to understand hot IPv4 checksums are calculated. As stated in the <a href=https://datatracker.ietf.org/doc/html/rfc791>Internet Protocol RFC 791</a>:</p><blockquote><p>&ldquo;The checksum field is the 16-bit ones&rsquo; complement of the ones&rsquo; complement sum of all 16-bit words in the header. For purposes of computing the checksum, the value of the checksum field is zero.&rdquo;</p></blockquote><p>This is quite a mouthful and personally, I found it difficult to grasp without seeing an example. For a great one, I recommend checking the <a href=https://en.wikipedia.org/wiki/IPv4_header_checksum#Examples>IPv4 header checksum Wikipedia page</a>.</p><p>In the case of compensating for changes in the destination IP address, this entails calculating the difference between the 16-bit sums of the original and the modified IP addresses and tweaking other fields appropriately. Note that the 16-bit sum will mean that <strong>the first and the third octets</strong> of each IP address in the sum are <strong>shifted left 8 bits</strong> in the checksum calculation.</p><p>In LTE networks, we can reliably predict the TTL of packets sent from some devices to the first mast, as it won&rsquo;t yet be decremented. This gives us the ability to compensate for changes in the <strong>first</strong> and <strong>third</strong> octets of the IP. To compensate for changes in the <strong>second</strong> and <strong>fourth</strong> octets, I performed an investigation by sending hand-crafted DNS packets with broken fields to a remotely hosted VM and checking if they&rsquo;re received and processed correctly. The aim was to establish which fields are not necessary for routing and could be modified. This was easily done using <a href=https://scapy.net/>Scapy</a>. Eventually, I found that the DSCP and ECN fields could be predicted and didn&rsquo;t impact routing, so these gave enough room for me to be able to compensate for changes in the second and fourth octets of the IP.</p><figure class=align-center><img loading=lazy src=img/ip-checksum.png#center alt="IP Checksum Diagram"></figure><h4 id=ip-checksum-compensation-code-example>IP Checksum Compensation Code Example<a hidden class=anchor aria-hidden=true href=#ip-checksum-compensation-code-example>#</a></h4><p>To verify if my IP checksum compensation code worked, I added an implementation of it to my test script from before.</p><p>To compensate for changes in the <strong>first</strong> and <strong>third</strong> IP octet using the TTL field:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span><span style=color:#75715e>/* Mask TTL */</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>// Store the TTL field plaintext
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#66d9ef>int</span> ttl_plaintext <span style=color:#f92672>=</span> <span style=color:#ae81ff>64</span>;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>// Calculate the difference in the 16-bit totals of the original and modified destination IPs
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#66d9ef>int</span> dest_ip_plaintext_total <span style=color:#f92672>=</span> (dest_ip_plaintext[<span style=color:#ae81ff>0</span>] <span style=color:#f92672>&lt;&lt;</span> <span style=color:#ae81ff>8</span>) <span style=color:#f92672>+</span> dest_ip_plaintext[<span style=color:#ae81ff>1</span>] <span style=color:#f92672>+</span> (dest_ip_plaintext[<span style=color:#ae81ff>2</span>] <span style=color:#f92672>&lt;&lt;</span> <span style=color:#ae81ff>8</span>) <span style=color:#f92672>+</span> dest_ip_plaintext[<span style=color:#ae81ff>3</span>];
</span></span><span style=display:flex><span><span style=color:#66d9ef>int</span> dest_ip_modified_total <span style=color:#f92672>=</span> (dest_ip_modified[<span style=color:#ae81ff>0</span>] <span style=color:#f92672>&lt;&lt;</span> <span style=color:#ae81ff>8</span>) <span style=color:#f92672>+</span> dest_ip_modified[<span style=color:#ae81ff>1</span>] <span style=color:#f92672>+</span> (dest_ip_modified[<span style=color:#ae81ff>2</span>] <span style=color:#f92672>&lt;&lt;</span> <span style=color:#ae81ff>8</span>) <span style=color:#f92672>+</span> dest_ip_modified[<span style=color:#ae81ff>3</span>];
</span></span><span style=display:flex><span><span style=color:#66d9ef>int</span> chksm_difference <span style=color:#f92672>=</span> dest_ip_plaintext_total <span style=color:#f92672>+</span> (ttl_plaintext <span style=color:#f92672>&lt;&lt;</span> <span style=color:#ae81ff>8</span>) <span style=color:#f92672>-</span> dest_ip_modified_total;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>// Extract only the higher byte from the difference that the TTL field can compensate for
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#66d9ef>int</span> ttl_modified <span style=color:#f92672>=</span> chksm_difference <span style=color:#f92672>&gt;&gt;</span> <span style=color:#ae81ff>8</span>;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>// Assert that the modified TTL field is valid
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>assert(ttl_modified <span style=color:#f92672>&gt;=</span> <span style=color:#ae81ff>20</span> <span style=color:#f92672>&amp;&amp;</span> <span style=color:#e6db74>&#34;TTL under 20: may not reach the destination&#34;</span>);
</span></span><span style=display:flex><span>assert(ttl_modified <span style=color:#f92672>&lt;=</span> <span style=color:#ae81ff>255</span> <span style=color:#f92672>&amp;&amp;</span> <span style=color:#e6db74>&#34;TTL over 255: too large&#34;</span>);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>// Calculate the bitmask
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#66d9ef>int</span> ttl_mask_val <span style=color:#f92672>=</span> ttl_plaintext <span style=color:#f92672>^</span>ttl_modified;
</span></span><span style=display:flex><span>std<span style=color:#f92672>::</span>valarray<span style=color:#f92672>&lt;</span><span style=color:#66d9ef>int</span><span style=color:#f92672>&gt;</span> ttl_mask <span style=color:#f92672>=</span> {ttl_mask_val};
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>// Apply the bitmask to the ciphertext
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#66d9ef>int</span> ttl_byte_offset <span style=color:#f92672>=</span> <span style=color:#ae81ff>10</span>;
</span></span><span style=display:flex><span>apply_mask(buf, ttl_mask, ttl_byte_offset);
</span></span></code></pre></div><p>To compensate for changes in the <strong>second</strong> and <strong>fourth</strong> IP octet using the DSCP and ECN fields:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span><span style=color:#75715e>/* Mask DSCP/ECN */</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>// Store the DSCP/ECN field plaintext
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#66d9ef>int</span> dscp_ecn_plaintext <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>// Extract only the lower byte from the difference that the DSCP/ECN field can compensate for
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#66d9ef>int</span> dscp_ecn_modified <span style=color:#f92672>=</span> chksm_difference <span style=color:#f92672>&amp;</span> <span style=color:#ae81ff>0xFF</span>;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>// Assert that the modified DSCP/ECN value is valid
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>assert(dscp_ecn_mod <span style=color:#f92672>&gt;=</span> <span style=color:#ae81ff>0</span> <span style=color:#f92672>&amp;&amp;</span> <span style=color:#e6db74>&#34;DSPCP/ECN under 1: invalid&#34;</span>);
</span></span><span style=display:flex><span>assert(dscp_ecn_mod <span style=color:#f92672>&lt;=</span> <span style=color:#ae81ff>255</span> <span style=color:#f92672>&amp;&amp;</span> <span style=color:#e6db74>&#34;DSPCP/ECN above 255: invalid&#34;</span>);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>// Calculate the bitmask
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#66d9ef>int</span> dscp_ecn_mask_val <span style=color:#f92672>=</span> dscp_ecn_plain <span style=color:#f92672>^</span>dscp_ecn_mod;
</span></span><span style=display:flex><span>std<span style=color:#f92672>::</span>valarray<span style=color:#f92672>&lt;</span><span style=color:#66d9ef>int</span><span style=color:#f92672>&gt;</span> dscp_ecn_mask <span style=color:#f92672>=</span> {dscp_ecn_mask_val};
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>// Apply the bitmask to the ciphertext
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#66d9ef>int</span> pdu_dscp_ecn_byte_offset <span style=color:#f92672>=</span> <span style=color:#ae81ff>3</span>;
</span></span><span style=display:flex><span>apply_mask(buf, dscp_ecn_mask, pdu_dscp_ecn_byte_offset);
</span></span></code></pre></div><h2 id=caveats-of-stream-cipher-attacks-on-ip-packets>Caveats of Stream Cipher Attacks on IP Packets<a hidden class=anchor aria-hidden=true href=#caveats-of-stream-cipher-attacks-on-ip-packets>#</a></h2><h3 id=impossible-to-compensate-for-changes>Impossible to Compensate for Changes<a hidden class=anchor aria-hidden=true href=#impossible-to-compensate-for-changes>#</a></h3><p>You may that it won&rsquo;t be possible to compensate for some changes in the fields, especially to the higher byte of the 16-bit sum. The lower byte can always carry into the higher byte, but the higher byte doesn&rsquo;t have this luxury. If it&rsquo;s not possible to find enough fields whose plaintext can be predicted, it may not be possible to compensate for any changes unless some external changes are made.</p><p>This is an issue that I have encountered, where the destination IP couldn&rsquo;t be compensated for. In my case, I was redirecting DNS packets to a remote VM that I controlled, so I had control over the modified destination IP. I fixed this issue by deploying a VM hosted by another provider or in another region, such that the IP would differ adequately.</p><h3 id=incorrect-udptcp-checksums>Incorrect UDP/TCP Checksums<a hidden class=anchor aria-hidden=true href=#incorrect-udptcp-checksums>#</a></h3><p>Another issue that could occur is that the UDP checksum will be incorrect, causing the receiver to discard the packet. This occurs because the UDP checksum is calculated separately from the IP checksum. If you control the receiver, this issue could be alleviated by ignoring UDP checksums. There is conflicting advice on how to do this online, so I wrote a short guide to disabling UDP checksum validation in Linux which you can find <a href=https://dominikrys.com/posts/disable-udp-checksum-validation/ title="How to Disable UDP Checksum Validation in Linux">here</a>.</p><p>I&rsquo;ve attempted to correct the UDP checksum by masking other fields in the packet as well. Below is a diagram of all the fields that are used to calculate the UDP checksum, where the red fields are from the IPv4 packet:</p><figure class=align-center><img loading=lazy src=img/udp-checksum.png#center alt="UDP Checksum Diagram"></figure><p>After modifying every non-payload field to see if the packets will be received, I found that Linux rejected them at the kernel level. The only promising change that worked was when part of the payload could be predicted and modified. Otherwise, pervasive changes would need to be made to the IP stack such that any incorrect fields are ignored and corrected.</p></div><footer class=post-footer><ul class=post-tags><li><a href=https://dominikrys.com/tags/c++/>C++</a></li><li><a href=https://dominikrys.com/tags/security/>Security</a></li><li><a href=https://dominikrys.com/tags/networking/>Networking</a></li></ul><nav class=paginav><a class=prev href=https://dominikrys.com/posts/cs-dissertation-tips/><span class=title>¬´ Prev</span><br><span>10 Tips for Getting a First in a Computer Science Dissertation</span>
</a><a class=next href=https://dominikrys.com/posts/learning-rust/><span class=title>Next ¬ª</span><br><span>How I Started Learning Rust</span></a></nav><ul class=share-buttons><li><a target=_blank rel="noopener noreferrer" aria-label="share Executing Stream Cipher Attacks on IP Packets on x" href="https://x.com/intent/tweet/?text=Executing%20Stream%20Cipher%20Attacks%20on%20IP%20Packets&amp;url=https%3a%2f%2fdominikrys.com%2fposts%2fstream-cipher-attacks-on-ip%2f&amp;hashtags=C%2b%2b%2cSecurity%2cNetworking"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentcolor"><path d="M512 62.554V449.446C512 483.97 483.97 512 449.446 512H62.554C28.03 512 0 483.97.0 449.446V62.554C0 28.03 28.029.0 62.554.0H449.446C483.971.0 512 28.03 512 62.554zM269.951 190.75 182.567 75.216H56L207.216 272.95 63.9 436.783h61.366L235.9 310.383l96.667 126.4H456L298.367 228.367l134-153.151H371.033zM127.633 110h36.468l219.38 290.065H349.5z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share Executing Stream Cipher Attacks on IP Packets on linkedin" href="https://www.linkedin.com/shareArticle?mini=true&amp;url=https%3a%2f%2fdominikrys.com%2fposts%2fstream-cipher-attacks-on-ip%2f&amp;title=Executing%20Stream%20Cipher%20Attacks%20on%20IP%20Packets&amp;summary=Executing%20Stream%20Cipher%20Attacks%20on%20IP%20Packets&amp;source=https%3a%2f%2fdominikrys.com%2fposts%2fstream-cipher-attacks-on-ip%2f"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentcolor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zM160.461 423.278V197.561h-75.04v225.717h75.04zm270.539.0V293.839c0-69.333-37.018-101.586-86.381-101.586-39.804.0-57.634 21.891-67.617 37.266v-31.958h-75.021c.995 21.181.0 225.717.0 225.717h75.02V297.222c0-6.748.486-13.492 2.474-18.315 5.414-13.475 17.767-27.434 38.494-27.434 27.135.0 38.007 20.707 38.007 51.037v120.768H431zM123.448 88.722C97.774 88.722 81 105.601 81 127.724c0 21.658 16.264 39.002 41.455 39.002h.484c26.165.0 42.452-17.344 42.452-39.002-.485-22.092-16.241-38.954-41.943-39.002z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share Executing Stream Cipher Attacks on IP Packets on reddit" href="https://reddit.com/submit?url=https%3a%2f%2fdominikrys.com%2fposts%2fstream-cipher-attacks-on-ip%2f&title=Executing%20Stream%20Cipher%20Attacks%20on%20IP%20Packets"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentcolor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zM446 265.638c0-22.964-18.616-41.58-41.58-41.58-11.211.0-21.361 4.457-28.841 11.666-28.424-20.508-67.586-33.757-111.204-35.278l18.941-89.121 61.884 13.157c.756 15.734 13.642 28.29 29.56 28.29 16.407.0 29.706-13.299 29.706-29.701.0-16.403-13.299-29.702-29.706-29.702-11.666.0-21.657 6.792-26.515 16.578l-69.105-14.69c-1.922-.418-3.939-.042-5.585 1.036-1.658 1.073-2.811 2.761-3.224 4.686l-21.152 99.438c-44.258 1.228-84.046 14.494-112.837 35.232-7.468-7.164-17.589-11.591-28.757-11.591-22.965.0-41.585 18.616-41.585 41.58.0 16.896 10.095 31.41 24.568 37.918-.639 4.135-.99 8.328-.99 12.576.0 63.977 74.469 115.836 166.33 115.836s166.334-51.859 166.334-115.836c0-4.218-.347-8.387-.977-12.493 14.564-6.47 24.735-21.034 24.735-38.001zM326.526 373.831c-20.27 20.241-59.115 21.816-70.534 21.816-11.428.0-50.277-1.575-70.522-21.82-3.007-3.008-3.007-7.882.0-10.889 3.003-2.999 7.882-3.003 10.885.0 12.777 12.781 40.11 17.317 59.637 17.317 19.522.0 46.86-4.536 59.657-17.321 3.016-2.999 7.886-2.995 10.885.008 3.008 3.011 3.003 7.882-.008 10.889zm-5.23-48.781c-16.373.0-29.701-13.324-29.701-29.698.0-16.381 13.328-29.714 29.701-29.714 16.378.0 29.706 13.333 29.706 29.714.0 16.374-13.328 29.698-29.706 29.698zM160.91 295.348c0-16.381 13.328-29.71 29.714-29.71 16.369.0 29.689 13.329 29.689 29.71.0 16.373-13.32 29.693-29.689 29.693-16.386.0-29.714-13.32-29.714-29.693z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share Executing Stream Cipher Attacks on IP Packets on facebook" href="https://facebook.com/sharer/sharer.php?u=https%3a%2f%2fdominikrys.com%2fposts%2fstream-cipher-attacks-on-ip%2f"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentcolor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H342.978V319.085h66.6l12.672-82.621h-79.272v-53.617c0-22.603 11.073-44.636 46.58-44.636H425.6v-70.34s-32.71-5.582-63.982-5.582c-65.288.0-107.96 39.569-107.96 111.204v62.971h-72.573v82.621h72.573V512h-191.104c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share Executing Stream Cipher Attacks on IP Packets on whatsapp" href="https://api.whatsapp.com/send?text=Executing%20Stream%20Cipher%20Attacks%20on%20IP%20Packets%20-%20https%3a%2f%2fdominikrys.com%2fposts%2fstream-cipher-attacks-on-ip%2f"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentcolor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zm-58.673 127.703c-33.842-33.881-78.847-52.548-126.798-52.568-98.799.0-179.21 80.405-179.249 179.234-.013 31.593 8.241 62.428 23.927 89.612l-25.429 92.884 95.021-24.925c26.181 14.28 55.659 21.807 85.658 21.816h.074c98.789.0 179.206-80.413 179.247-179.243.018-47.895-18.61-92.93-52.451-126.81zM263.976 403.485h-.06c-26.734-.01-52.954-7.193-75.828-20.767l-5.441-3.229-56.386 14.792 15.05-54.977-3.542-5.637c-14.913-23.72-22.791-51.136-22.779-79.287.033-82.142 66.867-148.971 149.046-148.971 39.793.014 77.199 15.531 105.329 43.692 28.128 28.16 43.609 65.592 43.594 105.4-.034 82.149-66.866 148.983-148.983 148.984zm81.721-111.581c-4.479-2.242-26.499-13.075-30.604-14.571-4.105-1.495-7.091-2.241-10.077 2.241-2.986 4.483-11.569 14.572-14.182 17.562-2.612 2.988-5.225 3.364-9.703 1.12-4.479-2.241-18.91-6.97-36.017-22.23C231.8 264.15 222.81 249.484 220.198 245s-.279-6.908 1.963-9.14c2.016-2.007 4.48-5.232 6.719-7.847 2.24-2.615 2.986-4.484 4.479-7.472 1.493-2.99.747-5.604-.374-7.846-1.119-2.241-10.077-24.288-13.809-33.256-3.635-8.733-7.327-7.55-10.077-7.688-2.609-.13-5.598-.158-8.583-.158-2.986.0-7.839 1.121-11.944 5.604-4.105 4.484-15.675 15.32-15.675 37.364.0 22.046 16.048 43.342 18.287 46.332 2.24 2.99 31.582 48.227 76.511 67.627 10.685 4.615 19.028 7.371 25.533 9.434 10.728 3.41 20.492 2.929 28.209 1.775 8.605-1.285 26.499-10.833 30.231-21.295 3.732-10.464 3.732-19.431 2.612-21.298-1.119-1.869-4.105-2.99-8.583-5.232z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share Executing Stream Cipher Attacks on IP Packets on telegram" href="https://telegram.me/share/url?text=Executing%20Stream%20Cipher%20Attacks%20on%20IP%20Packets&amp;url=https%3a%2f%2fdominikrys.com%2fposts%2fstream-cipher-attacks-on-ip%2f"><svg viewBox="2 2 28 28" height="30" width="30" fill="currentcolor"><path d="M26.49 29.86H5.5a3.37 3.37.0 01-2.47-1 3.35 3.35.0 01-1-2.47V5.48A3.36 3.36.0 013 3 3.37 3.37.0 015.5 2h21A3.38 3.38.0 0129 3a3.36 3.36.0 011 2.46V26.37a3.35 3.35.0 01-1 2.47 3.38 3.38.0 01-2.51 1.02zm-5.38-6.71a.79.79.0 00.85-.66L24.73 9.24a.55.55.0 00-.18-.46.62.62.0 00-.41-.17q-.08.0-16.53 6.11a.59.59.0 00-.41.59.57.57.0 00.43.52l4 1.24 1.61 4.83a.62.62.0 00.63.43.56.56.0 00.4-.17L16.54 20l4.09 3A.9.9.0 0021.11 23.15zM13.8 20.71l-1.21-4q8.72-5.55 8.78-5.55c.15.0.23.0.23.16a.18.18.0 010 .06s-2.51 2.3-7.52 6.8z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share Executing Stream Cipher Attacks on IP Packets on ycombinator" href="https://news.ycombinator.com/submitlink?t=Executing%20Stream%20Cipher%20Attacks%20on%20IP%20Packets&u=https%3a%2f%2fdominikrys.com%2fposts%2fstream-cipher-attacks-on-ip%2f"><svg width="30" height="30" viewBox="0 0 512 512" fill="currentcolor" xmlns:inkscape="http://www.inkscape.org/namespaces/inkscape"><path d="M449.446.0C483.971.0 512 28.03 512 62.554V449.446C512 483.97 483.97 512 449.446 512H62.554C28.03 512 0 483.97.0 449.446V62.554C0 28.03 28.029.0 62.554.0H449.446zM183.8767 87.9921h-62.034L230.6673 292.4508V424.0079h50.6655V292.4508L390.1575 87.9921H328.1233L256 238.2489z"/></svg></a></li></ul></footer><div id=disqus_thread></div><script>window.disqus_config=function(){},function(){if(["localhost","127.0.0.1"].indexOf(window.location.hostname)!=-1){document.getElementById("disqus_thread").innerHTML="Disqus comments not available by default when the website is previewed locally.";return}var t=document,e=t.createElement("script");e.async=!0,e.src="//dominikrys.disqus.com/embed.js",e.setAttribute("data-timestamp",+new Date),(t.head||t.body).appendChild(e)}()</script><noscript>Please enable JavaScript to view the <a href=https://disqus.com/?ref_noscript>comments powered by Disqus.</a></noscript><a href=https://disqus.com class=dsq-brlink>comments powered by <span class=logo-disqus>Disqus</span></a></article></main><footer class=footer><span>&copy; 2025 <a href=https://dominikrys.com/>Dominik Rys</a></span> ¬∑
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script><script>document.querySelectorAll("pre > code").forEach(e=>{const n=e.parentNode.parentNode,t=document.createElement("button");t.classList.add("copy-code"),t.innerHTML="copy";function s(){t.innerHTML="copied!",setTimeout(()=>{t.innerHTML="copy"},2e3)}t.addEventListener("click",t=>{if("clipboard"in navigator){navigator.clipboard.writeText(e.textContent),s();return}const n=document.createRange();n.selectNodeContents(e);const o=window.getSelection();o.removeAllRanges(),o.addRange(n);try{document.execCommand("copy"),s()}catch{}o.removeRange(n)}),n.classList.contains("highlight")?n.appendChild(t):n.parentNode.firstChild==n||(e.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName=="TABLE"?e.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(t):e.parentNode.appendChild(t))})</script></body></html>